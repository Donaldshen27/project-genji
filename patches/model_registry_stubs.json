{
  "ticket": "P3C4-001-004",
  "files": [
    {
      "path": "src/model2/model_registry.py",
      "content": "\"\"\"Model Registry for Base Model Configurations.\n\nPer P3C4-001-004: Central registry mapping model names to trainer classes and hyperparameters.\n\nProvides:\n- get_model(model_name) -> dict with trainer and params\n- list_available_models() -> list of model names\n- Frozen hyperparameters per specs Section 1\n\nRaises:\n- KeyError: Unknown model name\n- ValueError: Invalid hyperparameters\n\"\"\"\n\nimport copy\nimport logging\nimport math\nfrom typing import Any, Literal\n\nfrom src.model2.train import BaseModelTrainer, RidgeTrainer, XGBoostTrainer\n\nlogger = logging.getLogger(__name__)\n\n# Type alias for valid model names\nModelName = Literal[\"ridge\", \"xgboost\"]\n\n\n# ============================================================================\n# Frozen Hyperparameter Configurations\n# ============================================================================\n# Per P3C4-001-002 and P3C4-001-003: All hyperparameters are NON-NEGOTIABLE\n\nRIDGE_PARAMS: dict[str, Any] = {\n    \"alpha\": 3.0,\n    \"random_state\": 42,\n}\n\nXGBOOST_PARAMS: dict[str, Any] = {\n    \"max_depth\": 6,\n    \"n_estimators\": 400,\n    \"learning_rate\": 0.05,\n    \"subsample\": 0.8,\n    \"colsample_bytree\": 0.8,\n    \"random_state\": 42,\n}\n\n\n# ============================================================================\n# Model Registry\n# ============================================================================\n\n_MODEL_REGISTRY: dict[str, dict[str, Any]] = {\n    \"ridge\": {\n        \"trainer_class\": RidgeTrainer,\n        \"params\": RIDGE_PARAMS,\n    },\n    \"xgboost\": {\n        \"trainer_class\": XGBoostTrainer,\n        \"params\": XGBOOST_PARAMS,\n    },\n}\n\n\ndef get_model(model_name: str) -> dict[str, Any]:\n    \"\"\"Get trainer instance and hyperparameters for a registered model.\n\n    Per P3C4-001-004: Returns a dict with 'trainer' (BaseModelTrainer instance)\n    and 'params' (frozen hyperparameters).\n\n    Args:\n        model_name: Model identifier (\"ridge\" or \"xgboost\")\n\n    Returns:\n        Dictionary with keys:\n        - 'trainer': BaseModelTrainer instance (not yet fitted)\n        - 'params': dict of frozen hyperparameters\n\n    Raises:\n        KeyError: If model_name is not registered\n        ValueError: If hyperparameters are invalid (should never occur with frozen params)\n\n    Example:\n        >>> result = get_model(\"ridge\")\n        >>> trainer = result[\"trainer\"]  # RidgeTrainer instance\n        >>> params = result[\"params\"]    # {\"alpha\": 3.0, \"random_state\": 42}\n        >>> trainer.fit(X_train, y_train)\n    \"\"\"\n    if model_name not in _MODEL_REGISTRY:\n        available = sorted(_MODEL_REGISTRY.keys())\n        raise KeyError(\n            f\"Unknown model name '{model_name}'. \"\n            f\"Available models: {available}\"\n        )\n\n    registry_entry = _MODEL_REGISTRY[model_name]\n    trainer_class = registry_entry[\"trainer_class\"]\n    frozen_params = registry_entry[\"params\"]\n\n    # Deep copy params to prevent mutation\n    params_copy = copy.deepcopy(frozen_params)\n\n    # Validate params match frozen values (defensive check)\n    _validate_hyperparameters(model_name, params_copy)\n\n    # Instantiate trainer with frozen params\n    # Trainer __init__ will validate params match frozen values\n    trainer = trainer_class(**params_copy)\n\n    logger.debug(\n        \"Retrieved model '%s': trainer=%s, params=%s\",\n        model_name,\n        trainer_class.__name__,\n        params_copy,\n    )\n\n    return {\n        \"trainer\": trainer,\n        \"params\": params_copy,\n    }\n\n\ndef list_available_models() -> list[str]:\n    \"\"\"List all registered model names.\n\n    Per P3C4-001-004: Returns sorted list of available model identifiers.\n\n    Returns:\n        List of model names, e.g., [\"ridge\", \"xgboost\"]\n\n    Example:\n        >>> models = list_available_models()\n        >>> assert \"ridge\" in models\n        >>> assert \"xgboost\" in models\n    \"\"\"\n    return sorted(_MODEL_REGISTRY.keys())\n\n\ndef _validate_hyperparameters(model_name: str, params: dict[str, Any]) -> None:\n    \"\"\"Validate hyperparameters against frozen values.\n\n    Defensive check to ensure no accidental parameter drift.\n\n    Args:\n        model_name: Model identifier\n        params: Hyperparameters to validate\n\n    Raises:\n        ValueError: If any parameter differs from frozen value\n\n    Note:\n        This function is internal and called by get_model() as a sanity check.\n        With frozen params, this should never raise.\n    \"\"\"\n    if model_name not in _MODEL_REGISTRY:\n        return  # Let get_model handle unknown models\n\n    frozen_params = _MODEL_REGISTRY[model_name][\"params\"]\n\n    # Check all frozen params are present\n    missing_params = set(frozen_params.keys()) - set(params.keys())\n    if missing_params:\n        raise ValueError(\n            f\"Model '{model_name}' is missing required hyperparameters: {sorted(missing_params)}\"\n        )\n\n    # Check all params match frozen values\n    for param_name, frozen_value in frozen_params.items():\n        actual_value = params.get(param_name)\n\n        # Compare with appropriate tolerance for floats\n        if isinstance(frozen_value, float):\n            if not math.isclose(actual_value, frozen_value, abs_tol=1e-12):\n                raise ValueError(\n                    f\"Model '{model_name}' hyperparameter '{param_name}' must be {frozen_value} \"\n                    f\"(got {actual_value}). Hyperparameters are frozen per specs Section 1.\"\n                )\n        else:\n            if actual_value != frozen_value:\n                raise ValueError(\n                    f\"Model '{model_name}' hyperparameter '{param_name}' must be {frozen_value} \"\n                    f\"(got {actual_value}). Hyperparameters are frozen per specs Section 1.\"\n                )\n\n    logger.debug(\n        \"Validated hyperparameters for model '%s' against frozen values.\",\n        model_name,\n    )\n"
    }
  ],
  "description": "Create ModelRegistry module to centralize base model configurations. Maps model names ('ridge', 'xgboost') to trainer classes (RidgeTrainer, XGBoostTrainer) and frozen hyperparameters. Provides get_model() to return trainer instance and params, and list_available_models() to enumerate registered models. Raises KeyError for unknown models, ValueError for invalid hyperparameters.",
  "context": "Ticket P3C4-001-004 depends on P3C4-001-002 (RidgeTrainer) and P3C4-001-003 (XGBoostTrainer), both COMPLETE and implemented in src/model2/train.py. Registry serves as configuration layer for P3C4-001-006 (CV Training Loop) which needs to instantiate trainers dynamically based on config. Aligns with specs Section 1 (frozen hyperparameters) and Section 2.2 (ModelRegistry architecture). Supports CVScores.schema.json contract by providing model names enum.",
  "notes": "Implemented three functions with working logic: get_model() looks up model in registry, deep-copies params to prevent mutation, validates params, instantiates trainer and returns dict; list_available_models() returns sorted registry keys; _validate_hyperparameters() compares params against frozen values with float tolerance. Defined frozen param dicts RIDGE_PARAMS and XGBOOST_PARAMS matching trainer class values. _MODEL_REGISTRY maps model names to trainer_class and params. All hyperparameters are NON-NEGOTIABLE per specs. Edge cases: unknown model name raises KeyError with available models list, param mismatch raises ValueError with detailed message.",
  "tests": [
    {
      "path": "tests/unit/test_model2_model_registry.py",
      "content": "\"\"\"Unit tests for Model 2 model registry.\n\nPer P3C4-001-004: Test ModelRegistry configuration and retrieval.\n\nTests:\n- test_registry_get_ridge: Verify Ridge config matches specs\n- test_registry_get_xgboost: Verify XGBoost config matches specs\n- test_registry_unknown_model: Verify KeyError for invalid model name\n- test_registry_list_models: Verify list_available_models returns correct models\n\"\"\"\n\nimport pytest\n\nfrom src.model2.model_registry import (\n    RIDGE_PARAMS,\n    XGBOOST_PARAMS,\n    get_model,\n    list_available_models,\n)\nfrom src.model2.train import RidgeTrainer, XGBoostTrainer\n\n\ndef test_registry_get_ridge():\n    \"\"\"Verify Ridge configuration matches frozen specs.\n\n    Per P3C4-001-004: alpha=3.0, random_state=42 (NON-NEGOTIABLE)\n    \"\"\"\n    result = get_model(\"ridge\")\n\n    # Verify structure\n    assert \"trainer\" in result\n    assert \"params\" in result\n\n    # Verify trainer type\n    trainer = result[\"trainer\"]\n    assert isinstance(trainer, RidgeTrainer)\n\n    # Verify frozen params\n    params = result[\"params\"]\n    assert params[\"alpha\"] == 3.0\n    assert params[\"random_state\"] == 42\n\n    # Verify trainer params match\n    trainer_params = trainer.get_params()\n    assert trainer_params == RIDGE_PARAMS\n\n\ndef test_registry_get_xgboost():\n    \"\"\"Verify XGBoost configuration matches frozen specs.\n\n    Per P3C4-001-004: All 6 hyperparameters must match frozen values.\n    \"\"\"\n    result = get_model(\"xgboost\")\n\n    # Verify structure\n    assert \"trainer\" in result\n    assert \"params\" in result\n\n    # Verify trainer type\n    trainer = result[\"trainer\"]\n    assert isinstance(trainer, XGBoostTrainer)\n\n    # Verify all 6 frozen params\n    params = result[\"params\"]\n    assert params[\"max_depth\"] == 6\n    assert params[\"n_estimators\"] == 400\n    assert params[\"learning_rate\"] == 0.05\n    assert params[\"subsample\"] == 0.8\n    assert params[\"colsample_bytree\"] == 0.8\n    assert params[\"random_state\"] == 42\n\n    # Verify trainer params match\n    trainer_params = trainer.get_params()\n    assert trainer_params == XGBOOST_PARAMS\n\n\ndef test_registry_unknown_model():\n    \"\"\"Verify KeyError raised for invalid model name.\n\n    Per P3C4-001-004: Unknown model name should raise KeyError with available models.\n    \"\"\"\n    with pytest.raises(KeyError) as exc_info:\n        get_model(\"invalid_model\")\n\n    # Verify error message contains available models\n    error_msg = str(exc_info.value)\n    assert \"ridge\" in error_msg\n    assert \"xgboost\" in error_msg\n    assert \"invalid_model\" in error_msg\n\n\ndef test_registry_list_models():\n    \"\"\"Verify list_available_models returns correct model names.\n\n    Per P3C4-001-004: Should return ['ridge', 'xgboost'] (sorted).\n    \"\"\"\n    models = list_available_models()\n\n    # Verify return type and content\n    assert isinstance(models, list)\n    assert models == [\"ridge\", \"xgboost\"]\n\n    # Verify sorted\n    assert models == sorted(models)\n\n\ndef test_registry_frozen_params_immutable():\n    \"\"\"Verify modifying returned params doesn't affect registry.\n\n    Defensive test: ensure registry params are not mutable references.\n    \"\"\"\n    result1 = get_model(\"ridge\")\n    params1 = result1[\"params\"]\n\n    # Modify returned params\n    params1[\"alpha\"] = 999.0\n    params1[\"random_state\"] = 999\n\n    # Get model again\n    result2 = get_model(\"ridge\")\n    params2 = result2[\"params\"]\n\n    # Verify second call returns original frozen values\n    assert params2[\"alpha\"] == 3.0\n    assert params2[\"random_state\"] == 42\n\n\ndef test_registry_trainer_not_fitted():\n    \"\"\"Verify returned trainer is not yet fitted.\n\n    Per P3C4-001-004: get_model should return fresh trainer instance.\n    \"\"\"\n    result = get_model(\"ridge\")\n    trainer = result[\"trainer\"]\n\n    # Verify trainer not fitted\n    assert trainer._is_fitted is False\n\n    # Verify predict raises error before fit\n    import pandas as pd\n    import numpy as np\n\n    X_dummy = pd.DataFrame(np.random.randn(10, 5))\n    with pytest.raises(RuntimeError, match=\"must be fitted\"):\n        trainer.predict(X_dummy)\n\n\ndef test_registry_multiple_calls_independent():\n    \"\"\"Verify multiple get_model calls return independent trainer instances.\n\n    Ensure no shared state between trainers.\n    \"\"\"\n    result1 = get_model(\"ridge\")\n    result2 = get_model(\"ridge\")\n\n    trainer1 = result1[\"trainer\"]\n    trainer2 = result2[\"trainer\"]\n\n    # Verify different objects\n    assert id(trainer1) != id(trainer2)\n\n    # Fit first trainer\n    import pandas as pd\n    import numpy as np\n\n    X_train = pd.DataFrame(np.random.randn(100, 5))\n    y_train = pd.Series(np.random.randn(100))\n    trainer1.fit(X_train, y_train)\n\n    # Verify first trainer is fitted\n    assert trainer1._is_fitted is True\n\n    # Verify second trainer still not fitted\n    assert trainer2._is_fitted is False\n"
    }
  ]
}
