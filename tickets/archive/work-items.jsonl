{"archived_at": "2025-10-14T19:58:21Z", "ticket_key": null, "work_item_id": "P3C4-001-002", "module": {"ticket_id": "P3C4-001-002", "title": "RidgeTrainer Implementation", "description": "Implement Ridge regression trainer with alpha=3.0, random_state=42", "module": "src/model2/base_models.py", "dependencies": ["P3C4-001-001"], "input": {"description": "Training data", "schema": "X: DataFrame (N_samples, N_features), y: Series (N_samples,)"}, "output": {"description": "Trained Ridge model", "schema": "Fitted sklearn.linear_model.Ridge object"}, "edge_cases": ["Handle singular matrix: Ridge regularization prevents this", "Empty training set: Raise ValueError", "y contains NaN: sklearn raises, propagate error", "X contains NaN: sklearn raises, propagate error"], "tests": ["test_ridge_trainer_fit: Verify fit on toy data (10 samples, 3 features)", "test_ridge_trainer_predict: Verify predictions match expected shape", "test_ridge_trainer_no_feature_importance: Verify get_feature_importance() returns None", "test_ridge_trainer_determinism: Two fits with same seed produce identical coef_"], "acceptance": "RidgeTrainer trains successfully on synthetic data, predictions deterministic"}}
{"archived_at": "2025-10-15T16:09:10Z", "ticket_key": null, "work_item_id": "P3C4-001-001", "module": {"ticket_id": "P3C4-001-001", "title": "BaseModelTrainer Abstract Interface", "description": "Define abstract base class for model trainers with consistent interface", "module": "src/model2/base_models.py", "dependencies": [], "input": {"description": "Abstract interface definition", "schema": "N/A"}, "output": {"description": "BaseModelTrainer class with abstract methods", "schema": "Python ABC with methods: fit(X, y), predict(X), get_feature_importance(), get_params()"}, "edge_cases": ["Subclasses must implement all abstract methods", "get_feature_importance() returns None for models without feature importance"], "tests": ["test_base_model_trainer_cannot_instantiate: Verify ABC cannot be instantiated directly", "test_base_model_trainer_interface: Verify all required methods exist"], "acceptance": "BaseModelTrainer class exists, cannot be instantiated, defines 4 abstract methods"}}
{"archived_at": "2025-10-15T18:04:36Z", "ticket_key": null, "work_item_id": "P3C4-001-004", "module": {"ticket_id": "P3C4-001-004", "title": "ModelRegistry Configuration", "description": "Create registry for base model configurations", "module": "src/model2/model_registry.py", "dependencies": ["P3C4-001-002", "P3C4-001-003"], "input": {"description": "Model name string", "schema": "model_name: Literal['ridge', 'xgboost']"}, "output": {"description": "Trainer instance and hyperparameters", "schema": "{'trainer': BaseModelTrainer, 'params': dict}"}, "edge_cases": ["Unknown model name: Raise KeyError with available models", "Invalid hyperparameters in config: Raise ValueError with validation message"], "tests": ["test_registry_get_ridge: Verify Ridge config matches specs (alpha=3.0, random_state=42)", "test_registry_get_xgboost: Verify XGBoost config matches specs (all 6 params correct)", "test_registry_unknown_model: Verify KeyError raised for invalid model name", "test_registry_list_models: Verify list_available_models() returns ['ridge', 'xgboost']"], "acceptance": "Registry returns correct trainer and params for both models"}}
{"archived_at": "2025-10-15T18:33:38Z", "ticket_key": null, "work_item_id": "P3C4-001-003", "module": {"ticket_id": "P3C4-001-003", "title": "XGBoostTrainer Implementation", "description": "Implement XGBoost trainer with frozen hyperparameters from specs", "module": "src/model2/base_models.py", "dependencies": ["P3C4-001-001"], "input": {"description": "Training data", "schema": "X: DataFrame (N_samples, N_features), y: Series (N_samples,)"}, "output": {"description": "Trained XGBoost model", "schema": "Fitted xgboost.XGBRegressor object"}, "edge_cases": ["Insufficient samples for tree depth: XGBoost handles gracefully", "Empty training set: Raise ValueError", "y contains NaN: XGBoost raises, propagate error", "Feature names with special chars: Sanitize feature names before training"], "tests": ["test_xgboost_trainer_fit: Verify fit on toy data", "test_xgboost_trainer_predict: Verify predictions match expected shape", "test_xgboost_trainer_feature_importance: Verify get_feature_importance() returns DataFrame with [feature, importance_gain, importance_weight]", "test_xgboost_trainer_determinism: Two fits with same seed produce identical predictions (max diff < 1e-6)"], "acceptance": "XGBoostTrainer trains successfully, extracts feature importance, predictions deterministic"}}
{"archived_at": "2025-10-15T22:54:29Z", "ticket_key": null, "work_item_id": "P3C4-001-005", "module": {"ticket_id": "P3C4-001-005", "title": "OOF Prediction Aggregation", "description": "Aggregate OOF predictions across CV folds into single DataFrame", "module": "src/model2/base_models.py", "dependencies": [], "input": {"description": "List of fold predictions", "schema": "List[Tuple[np.ndarray indices, np.ndarray predictions, int fold_id]]"}, "output": {"description": "Aggregated OOF predictions", "schema": "DataFrame with MultiIndex (instrument, datetime), columns [prediction, fold_id]"}, "edge_cases": ["Duplicate indices across folds: Raise ValueError with overlap info", "Missing indices (incomplete coverage): Log warning with missing count", "Empty fold: Skip fold, log warning", "Prediction NaN: Raise ValueError with fold and index info"], "tests": ["test_oof_aggregation_full_coverage: Verify all indices present exactly once", "test_oof_aggregation_duplicate_indices: Verify ValueError on overlapping folds", "test_oof_aggregation_missing_indices: Verify warning logged for missing indices", "test_oof_aggregation_nan_prediction: Verify ValueError on NaN predictions"], "acceptance": "Aggregation handles 5 folds correctly, detects overlaps and gaps"}}
